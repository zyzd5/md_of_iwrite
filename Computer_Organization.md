## 大写字母的查表
>`CAM` -> `Content Addressed Memory` -> 相联存储器   
`FIFO` -> `First Input First Output` -> 先入先出队列
`LRU` -> `Least Recently Used` -> 最近最少使用
`LFU` -> `least frequently used` -> 最不经常使用
`CPI` -> `Cycle Per Instruction` -> 平均执行周期数
`TLB` -> `translation lookaside buffer` -> 存放虚拟地址到物理地址的转换表

## 加减乘除
`加减`暂时没啥说的
  
  如果是`1011，0011`这类没有小数点的除法直接除即可  
> $1101 \div 0011$              \
                                \
$0011\sqrt{1101}$

如果是 $x=0.01101$,$y=0.11110$，这时使用除法就需要`恢复余数法`或者`加减交替原码阵列法`  

我还没研究`恢复余数法`  

以下是`加减交替原码阵列法`
![加减交替原码阵列法](pictures/加减交替原码阵列法.png) 
写出$x_补, -y_补, |y|_补$

第一步用$x_补+-y_补$，结果的`正负`
`正`商`1`，`负`商`0`，然后结果`左`移，根据结果的`正负`来决定加$-y_补$或者$|y|_补$，`正`则加$-y_补$，`负`则加$|y|_补$，这样子商的位数会逐渐增多，够要求了就是结果商  



`cache命中` : cpu向cache请求数据，在cache中查找到了即为`cache命中`，反正则为 `cache不命中`

`地址映射方式`有 `直接方式`，`全相联方式`，`组相联方式`  
####  cache和主存映射关系的前置知识  
cache分为一些`缓存行`，主存中为`数据块`，行的结构为`标记`和`数据块`，标记中为主存中对应数据块的`地址`，cache中的`数据块`为主存中的对应`数据块`
#### 直接方式 :   
`直接方式`是通过算法规定了主存中的`数据块`该在cache中的`特定行`，当cpu请求到冲突位置时，会重新加载该在`相同位置`的数据块到冲突位置
 
#### 全相联方式 : 
`全相联方式`和`直接方式`类似，不区分特定加载位置，所有位置都可以加载，冲突时替换方式采用`LRU(Least Recently Used)`方式替换
#### 组相联方式 :  
组相联方式介于全相联方式和直接方式，提前将主存中的数据块做`分组处理`，组之间会添加索引，当cache向主存中请求数据时，会传入`索引`，`标记`和`数据块`，当一个块过大时，会请求更多的cache行来储存数据

---  
在一段时间内总是经常访问某些页对应的页表项存放在高速缓冲器组成的快表（TLB）中。放在主存中的页表称为慢表（Page）。 在地址转换时，首先查找快表，若命中，则无须访问主存中的页表。
>注：快表是在转换地址时加速；Cache是在访向数据时加速。
---


* 相联存储器 : 属于按内容访问的存储器。

原理：把数据或数据某一独立单元作为关键字，用该关键字和存储器的每个存储单元比较，相同则表示找到对应的存储单元。